#!/bin/bash
set -euo pipefail

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# shellcheck source=lib/logging.sh
. "${REPO_ROOT}/lib/logging.sh"
# shellcheck source=lib/cli_core.sh
. "${REPO_ROOT}/lib/cli_core.sh"
# shellcheck source=lib/recipe_loader.sh
. "${REPO_ROOT}/lib/recipe_loader.sh"
# shellcheck source=lib/inventory.sh
. "${REPO_ROOT}/lib/inventory.sh"

hz__apply_global_flags() {
  ARGS_OUT=()
  local a v
  for a in "$@"; do
    case "$a" in
      -v|--verbose)
        LOG_LEVEL="DEBUG"
        HZ_DEBUG="1"
        ;;
      -q|--quiet)
        LOG_LEVEL="ERROR"
        ;;
      --dry-run)
        HZ_DRY_RUN="1"
        ;;
      --dry-run=*)
        v="${a#--dry-run=}"
        HZ_DRY_RUN="${v}"
        ;;
      *)
        ARGS_OUT+=("$a")
        ;;
    esac
  done
  export LOG_LEVEL
  export HZ_DEBUG="${HZ_DEBUG:-0}"
  export HZ_DRY_RUN="${HZ_DRY_RUN:-0}"
}

hz__parse_install_args() {
  RECIPE_NAME=""
  HZ_HOST=""
  HZ_TARGET_INPUT=""
  HZ_LOCAL_MODE="0"
  HZ_HEADLESS="0"

  local a
  while [[ $# -gt 0 ]]; do
    a="$1"
    case "$a" in
      --host=*) HZ_HOST="${a#--host=}"; shift ;;
      --host) shift; HZ_HOST="${1:-}"; shift || true ;;
      --target=*) HZ_TARGET_INPUT="${a#--target=}"; shift ;;
      --target) shift; HZ_TARGET_INPUT="${1:-}"; shift || true ;;
      --local-mode) HZ_LOCAL_MODE="1"; shift ;;
      --headless) HZ_HEADLESS="1"; shift ;;
      --) shift; break ;;
      -*) log_error "unknown flag for install: ${a}"; return 1 ;;
      *)
        if [[ -z "$RECIPE_NAME" ]]; then
          RECIPE_NAME="$a"
        else
          log_error "unexpected extra arg for install: ${a}"
          return 1
        fi
        shift
        ;;
    esac
  done

  [[ -n "$RECIPE_NAME" ]] || return 1
  return 0
}

hz__should_record() {
  local cmd="${1:-}"
  [[ "${HZ_NO_RECORD:-0}" == "1" ]] && return 1
  case "$cmd" in
    install|diagnose|doctor|run) return 0 ;;
    *) return 1 ;;
  esac
}

hz__record_target_label() {
  local fallback
  fallback="$(hostname -s 2>/dev/null || echo localhost)"
  if [[ -n "${HZ_TARGET_INPUT:-}" ]]; then
    echo "${HZ_TARGET_INPUT}"
  elif [[ -n "${HZ_HOST:-}" ]]; then
    echo "${HZ_HOST}"
  else
    echo "${fallback}"
  fi
}

hz__run_with_recording() {
  local target_label="$1"
  local cmd_label="$2"
  shift 2

  local logfile
  logfile="$(hz_record_prepare "$target_label" "$cmd_label")"

  log_info "recording: ${logfile}"

  local had_errexit=0
  [[ $- == *e* ]] && had_errexit=1
  set +e

  "$@" \
    > >(tee -a "$logfile") \
    2> >(tee -a "$logfile" >&2)
  local rc=$?

  (( had_errexit == 1 )) && set -e
  return "$rc"
}

hz__cmd_ping() {
  local target=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --target) target="${2:-}"; shift 2 ;;
      --target=*) target="${1#*=}"; shift ;;
      -h|--help)
        echo "Usage: hz ping --target user@host|alias"
        return 0
        ;;
      *)
        echo "Unknown argument for ping: $1" >&2
        echo "Usage: hz ping --target user@host|alias" >&2
        return 1
        ;;
    esac
  done

  if [[ -z "${target}" ]]; then
    echo "ping: missing --target" >&2
    echo "Usage: hz ping --target user@host|alias" >&2
    return 1
  fi

  if declare -F inventory_resolve_target >/dev/null 2>&1; then
    inventory_resolve_target "${target}" || return 1
    target="${HZ_RESOLVED_TARGET:-$target}"
  fi

  if ! command -v ssh_test >/dev/null 2>&1; then
    echo "ping: ssh transport not available (ssh_test not found)" >&2
    return 1
  fi

  log_info "ping: testing ssh connectivity to target=${target}"
  if ssh_test "${target}"; then
    log_info "ping: ok"
    return 0
  else
    local rc=$?
    log_error "ping: failed (rc=${rc})"
    return "${rc}"
  fi
}

hz__dispatch_install() {
  export HZ_HOST
  export HZ_LOCAL_MODE
  export HZ_HEADLESS

  # Remote dispatch sits inside recording wrapper when enabled.
  if [[ -n "${HZ_TARGET_INPUT:-}" && "${HZ_LOCAL_MODE:-0}" != "1" ]]; then
    if ! declare -F remote_execute_recipe >/dev/null 2>&1; then
      log_error "install: remote runner not available (missing lib/remote_runner.sh)"
      return 2
    fi
    remote_execute_recipe "${RECIPE_NAME}" "${HZ_TARGET_INPUT}" "${HZ_HOST:-}"
    return $?
  fi

  hz_recipe_install "${RECIPE_NAME}"
  return $?
}

main() {
  hz__apply_global_flags "$@"
  set -- "${ARGS_OUT[@]}"

  hz_validate_dry_run || return 1

  local cmd="${1:-}"
  case "${cmd}" in
    ""|help|-h|--help)
      hz_usage
      return 0
      ;;
    version|--version)
      hz_read_version
      return 0
      ;;
    check)
      shift || true
      hz_run_check
      return $?
      ;;
    diagnose|doctor)
      shift || true
      if hz__should_record "diagnose"; then
        hz__run_with_recording "$(hostname -s 2>/dev/null || echo localhost)" "diagnose" \
          bash "${REPO_ROOT}/tools/diagnostics/run.sh" "$@"
        return $?
      fi
      bash "${REPO_ROOT}/tools/diagnostics/run.sh" "$@"
      return $?
      ;;
    ping)
      shift || true
      hz__cmd_ping "$@"
      return $?
      ;;
    install)
      shift || true
      if ! hz__parse_install_args "$@"; then
        hz_usage
        return 1
      fi

      local record_target record_cmd
      record_target="$(hz__record_target_label)"
      record_cmd="install-${RECIPE_NAME}"

      if hz__should_record "install"; then
        hz__run_with_recording "${record_target}" "${record_cmd}" hz__dispatch_install
        return $?
      fi

      hz__dispatch_install
      return $?
      ;;
    recipe)
      shift || true
      case "${1:-}" in
        list) hz_list_targets "recipes"; return 0 ;;
        "") hz_usage; return 1 ;;
        *)
          [[ $# -ge 2 ]] || { hz_usage; return 1; }
          hz_run_target "recipes" "$1" "$2"
          return $?
          ;;
      esac
      ;;
    module)
      shift || true
      case "${1:-}" in
        list) hz_list_targets "modules"; return 0 ;;
        "") hz_usage; return 1 ;;
        *)
          [[ $# -ge 2 ]] || { hz_usage; return 1; }
          hz_run_target "modules" "$1" "$2"
          return $?
          ;;
      esac
      ;;
    *)
      log_error "invalid subcommand: ${cmd}"
      hz_usage
      return 1
      ;;
  esac
}

main "$@"
